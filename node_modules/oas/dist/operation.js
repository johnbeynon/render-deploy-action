"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.Webhook = exports.Callback = void 0;
var RMOAS = __importStar(require("./rmoas.types"));
var dedupe_common_parameters_1 = __importDefault(require("./lib/dedupe-common-parameters"));
var find_schema_definition_1 = __importDefault(require("./lib/find-schema-definition"));
var get_parameters_as_json_schema_1 = __importDefault(require("./operation/get-parameters-as-json-schema"));
var get_response_as_json_schema_1 = __importDefault(require("./operation/get-response-as-json-schema"));
var get_requestbody_examples_1 = __importDefault(require("./operation/get-requestbody-examples"));
var get_callback_examples_1 = __importDefault(require("./operation/get-callback-examples"));
var get_response_examples_1 = __importDefault(require("./operation/get-response-examples"));
var matches_mimetype_1 = __importDefault(require("./lib/matches-mimetype"));
var utils_1 = require("./utils");
var Operation = /** @class */ (function () {
    function Operation(api, path, method, operation) {
        this.schema = operation;
        this.api = api;
        this.path = path;
        this.method = method;
        this.contentType = undefined;
        this.requestBodyExamples = undefined;
        this.responseExamples = undefined;
        this.callbackExamples = undefined;
    }
    Operation.prototype.getSummary = function () {
        var _a;
        if (this.api.paths[this.path].summary) {
            return this.api.paths[this.path].summary;
        }
        return ((_a = this.schema) === null || _a === void 0 ? void 0 : _a.summary) ? this.schema.summary.trim() : undefined;
    };
    Operation.prototype.getDescription = function () {
        var _a;
        if (this.api.paths[this.path].description) {
            return this.api.paths[this.path].description;
        }
        return ((_a = this.schema) === null || _a === void 0 ? void 0 : _a.description) ? this.schema.description.trim() : undefined;
    };
    Operation.prototype.getContentType = function () {
        var _this = this;
        if (this.contentType) {
            return this.contentType;
        }
        var types = [];
        if (this.schema.requestBody) {
            if ('$ref' in this.schema.requestBody) {
                this.schema.requestBody = (0, find_schema_definition_1["default"])(this.schema.requestBody.$ref, this.api);
            }
            if ('content' in this.schema.requestBody) {
                types = Object.keys(this.schema.requestBody.content);
            }
        }
        this.contentType = 'application/json';
        if (types && types.length) {
            this.contentType = types[0];
        }
        // Favor JSON if it exists
        types.forEach(function (t) {
            if (t.match(/json/)) {
                _this.contentType = t;
            }
        });
        return this.contentType;
    };
    Operation.prototype.isFormUrlEncoded = function () {
        return matches_mimetype_1["default"].formUrlEncoded(this.getContentType());
    };
    Operation.prototype.isMultipart = function () {
        return matches_mimetype_1["default"].multipart(this.getContentType());
    };
    Operation.prototype.isJson = function () {
        return matches_mimetype_1["default"].json(this.getContentType());
    };
    Operation.prototype.isXml = function () {
        return matches_mimetype_1["default"].xml(this.getContentType());
    };
    /**
     * Returns an array of all security requirements associated wtih this operation. If none are defined at the operation
     * level, the securities for the entire API definition are returned (with an empty array as a final fallback).
     *
     */
    Operation.prototype.getSecurity = function () {
        var _a, _b;
        if (!((_b = (_a = this.api) === null || _a === void 0 ? void 0 : _a.components) === null || _b === void 0 ? void 0 : _b.securitySchemes)) {
            return [];
        }
        return this.schema.security || this.api.security || [];
    };
    /**
     * Retrieve a collection of grouped security schemes. The inner array determines and-grouped security schemes, the
     * outer array determines or-groups.
     *
     * @see {@link https://swagger.io/docs/specification/authentication/#multiple}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#security-requirement-object}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#securityRequirementObject}
     * @param filterInvalid Optional flag that, when set to `true`, filters out invalid/nonexistent security schemes,
     *    rather than returning `false`.
     */
    Operation.prototype.getSecurityWithTypes = function (filterInvalid) {
        var _this = this;
        if (filterInvalid === void 0) { filterInvalid = false; }
        var securityRequirements = this.getSecurity();
        return securityRequirements.map(function (requirement) {
            var keys;
            try {
                keys = Object.keys(requirement);
            }
            catch (e) {
                return false;
            }
            var keysWithTypes = keys.map(function (key) {
                var security;
                try {
                    // Remove the reference type, because we know this will be dereferenced
                    security = _this.api.components.securitySchemes[key];
                }
                catch (e) {
                    return false;
                }
                if (!security)
                    return false;
                var type = null;
                if (security.type === 'http') {
                    if (security.scheme === 'basic')
                        type = 'Basic';
                    else if (security.scheme === 'bearer')
                        type = 'Bearer';
                    else
                        type = security.type;
                }
                else if (security.type === 'oauth2') {
                    type = 'OAuth2';
                }
                else if (security.type === 'apiKey') {
                    if (security["in"] === 'query')
                        type = 'Query';
                    else if (security["in"] === 'header')
                        type = 'Header';
                    else if (security["in"] === 'cookie')
                        type = 'Cookie';
                    else
                        type = security.type;
                }
                else {
                    return false;
                }
                security._key = key;
                return { type: type, security: security };
            });
            if (filterInvalid)
                return keysWithTypes.filter(function (key) { return key !== false; });
            return keysWithTypes;
        });
    };
    /**
     * Retrieve an object where the keys are unique scheme types, and the values are arrays containing each security
     * scheme of that type.
     *
     */
    Operation.prototype.prepareSecurity = function () {
        var securitiesWithTypes = this.getSecurityWithTypes();
        return securitiesWithTypes.reduce(function (prev, securities) {
            if (!securities)
                return prev;
            securities.forEach(function (security) {
                // Remove non-existent schemes
                if (!security)
                    return;
                if (!prev[security.type])
                    prev[security.type] = [];
                // Only add schemes we haven't seen yet.
                var exists = prev[security.type].findIndex(function (sec) { return sec._key === security.security._key; });
                if (exists < 0) {
                    prev[security.type].push(security.security);
                }
            });
            return prev;
        }, {});
    };
    Operation.prototype.getHeaders = function () {
        var _this = this;
        this.headers = {
            request: [],
            response: []
        };
        var security = this.prepareSecurity();
        if (security.Header) {
            this.headers.request = security.Header.map(function (h) {
                return h.name;
            });
        }
        if (security.Bearer || security.Basic) {
            this.headers.request.push('Authorization');
        }
        if (security.Cookie) {
            this.headers.request.push('Cookie');
        }
        if (this.schema.parameters) {
            this.headers.request = this.headers.request.concat(
            // Remove the reference object because we will have already dereferenced
            this.schema.parameters
                .map(function (p) {
                if (p["in"] && p["in"] === 'header')
                    return p.name;
                return undefined;
            })
                .filter(function (p) { return p; }));
        }
        if (this.schema.responses) {
            this.headers.response = Object.keys(this.schema.responses)
                // Remove the reference object because we will have already dereferenced
                .filter(function (r) { return _this.schema.responses[r].headers; })
                .map(function (r) {
                // Remove the reference object because we will have already dereferenced
                return Object.keys(_this.schema.responses[r].headers);
            })
                .reduce(function (a, b) { return a.concat(b); }, []);
        }
        // If the operation doesn't already specify a 'content-type' request header,
        // we check if the path operation request body contains content, which implies that
        // we should also include the 'content-type' header.
        if (!this.headers.request.includes('Content-Type') && this.schema.requestBody) {
            if (this.schema.requestBody.content &&
                Object.keys(this.schema.requestBody.content)) {
                this.headers.request.push('Content-Type');
            }
        }
        // This is a similar approach, but in this case if we check the response content
        // and prioritize the 'accept' request header and 'content-type' request header
        if (this.schema.responses) {
            if (Object.keys(this.schema.responses).some(function (response) { return !!_this.schema.responses[response].content; })) {
                if (!this.headers.request.includes('Accept'))
                    this.headers.request.push('Accept');
                if (!this.headers.response.includes('Content-Type'))
                    this.headers.response.push('Content-Type');
            }
        }
        return this.headers;
    };
    /**
     * Determine if the operation has an operation present in its schema.
     *
     */
    Operation.prototype.hasOperationId = function () {
        return 'operationId' in this.schema;
    };
    /**
     * Get an `operationId` for this operation. If one is not present (it's not required by the spec!)
     * a hash of the path and method will be returned instead.
     *
     * @param opts
     * @param opts.camelCase Generate a JS method-friendly operation ID when one isn't present.
     */
    Operation.prototype.getOperationId = function (opts) {
        if ('operationId' in this.schema) {
            return this.schema.operationId;
        }
        var method = this.method.toLowerCase();
        var operationId = this.path
            .replace(/[^a-zA-Z0-9]/g, '-') // Remove weird characters
            .replace(/^-|-$/g, '') // Don't start or end with -
            .replace(/--+/g, '-') // Remove double --'s
            .toLowerCase();
        if (opts === null || opts === void 0 ? void 0 : opts.camelCase) {
            operationId = operationId.replace(/[^a-zA-Z0-9]+(.)/g, function (_, chr) { return chr.toUpperCase(); });
            // If the generated operationId already starts with the method (eg. `getPets`) we don't want
            // to double it up into `getGetPets`.
            if (operationId.startsWith(method)) {
                return operationId;
            }
            operationId = operationId.charAt(0).toUpperCase() + operationId.slice(1);
            return "".concat(method).concat(operationId);
        }
        return "".concat(method, "_").concat(operationId);
    };
    /**
     * Return an array of all tags, and their metadata, that exist on this operation.
     *
     */
    Operation.prototype.getTags = function () {
        if (!('tags' in this.schema)) {
            return [];
        }
        var oasTagMap = new Map();
        if ('tags' in this.api) {
            this.api.tags.forEach(function (tag) {
                oasTagMap.set(tag.name, tag);
            });
        }
        var oasTags = Object.fromEntries(oasTagMap);
        var tags = [];
        if (Array.isArray(this.schema.tags)) {
            this.schema.tags.forEach(function (tag) {
                if (tag in oasTags) {
                    tags.push(oasTags[tag]);
                }
                else {
                    tags.push({
                        name: tag
                    });
                }
            });
        }
        return tags;
    };
    /**
     * Return is the operation is flagged as `deprecated` or not.
     *
     */
    Operation.prototype.isDeprecated = function () {
        return 'deprecated' in this.schema ? this.schema.deprecated : false;
    };
    /**
     * Determine if the operation has any (non-request body) parameters.
     *
     */
    Operation.prototype.hasParameters = function () {
        return !!this.getParameters().length;
    };
    /**
     * Return the parameters (non-request body) on the operation.
     *
     */
    Operation.prototype.getParameters = function () {
        var _a, _b, _c, _d;
        var parameters = (((_a = this.schema) === null || _a === void 0 ? void 0 : _a.parameters) || []);
        var commonParams = (((_d = (_c = (_b = this.api) === null || _b === void 0 ? void 0 : _b.paths) === null || _c === void 0 ? void 0 : _c[this.path]) === null || _d === void 0 ? void 0 : _d.parameters) || []);
        if (commonParams.length) {
            parameters = parameters.concat((0, dedupe_common_parameters_1["default"])(parameters, commonParams) || []);
        }
        return parameters;
    };
    /**
     * Determine if this operation has any required parameters.
     *
     */
    Operation.prototype.hasRequiredParameters = function () {
        return this.getParameters().some(function (param) { return 'required' in param && param.required; });
    };
    /**
     * Convert the operation into an array of JSON Schema schemas for each available type of parameter available on the
     * operation.
     *
     * @param globalDefaults Contains an object of user defined schema defaults.
     */
    Operation.prototype.getParametersAsJsonSchema = function (globalDefaults) {
        if (this.parameterJsonSchema) {
            return this.parameterJsonSchema;
        }
        this.parameterJsonSchema = (0, get_parameters_as_json_schema_1["default"])(this, this.api, globalDefaults);
        return this.parameterJsonSchema;
    };
    /**
     * Get a single response for this status code, formatted as JSON schema.
     *
     * @param statusCode
     */
    Operation.prototype.getResponseAsJsonSchema = function (statusCode) {
        return (0, get_response_as_json_schema_1["default"])(this, this.api, statusCode);
    };
    /**
     * Get an array of all valid response status codes for this operation.
     *
     */
    Operation.prototype.getResponseStatusCodes = function () {
        return this.schema.responses ? Object.keys(this.schema.responses) : [];
    };
    /**
     * Determine if the operation has any request bodies.
     *
     */
    Operation.prototype.hasRequestBody = function () {
        return !!this.schema.requestBody;
    };
    /**
     * Retrieve the list of all available media types that the operations request body can accept.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#mediaTypeObject}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#mediaTypeObject}
     */
    Operation.prototype.getRequestBodyMediaTypes = function () {
        if (!this.hasRequestBody()) {
            return [];
        }
        var requestBody = this.schema.requestBody;
        if (RMOAS.isRef(requestBody)) {
            // If the request body is still a `$ref` pointer we should return false because this library assumes that you've
            // run dereferencing beforehand.
            return [];
        }
        return Object.keys(requestBody.content);
    };
    /**
     * Determine if this operation has a required request body.
     *
     */
    Operation.prototype.hasRequiredRequestBody = function () {
        if (!this.hasRequestBody()) {
            return false;
        }
        var requestBody = this.schema.requestBody;
        if (RMOAS.isRef(requestBody)) {
            return false;
        }
        if (requestBody.required) {
            return true;
        }
        // The OpenAPI spec isn't clear on the differentiation between schema `required` and
        // `requestBody.required` because you can have required top-level schema properties but a
        // non-required requestBody that negates each other.
        //
        // To kind of work ourselves around this and present a better QOL for this accessor, if at this
        // final point where we don't have a required request body, but the underlying Media Type Object
        // schema says that it has required properties then we should ultimately recognize that this
        // request body is required -- even as the request body description says otherwise.
        return !!this.getParametersAsJsonSchema()
            .filter(function (js) { return ['body', 'formData'].includes(js.type); })
            .find(function (js) { return js.schema && Array.isArray(js.schema.required) && js.schema.required.length; });
    };
    /**
     * Retrieve a specific request body content schema off this operation.
     *
     * If no media type is supplied this will return either the first available JSON-like request body, or the first
     * available if there are no JSON-like media types present. When this return comes back it's in the form of an array
     * with the first key being the selected media type, followed by the media type object in question.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#mediaTypeObject}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#mediaTypeObject}
     * @param mediaType Specific request body media type to retrieve if present.
     */
    Operation.prototype.getRequestBody = function (mediaType) {
        if (!this.hasRequestBody()) {
            return false;
        }
        var requestBody = this.schema.requestBody;
        if (RMOAS.isRef(requestBody)) {
            // If the request body is still a `$ref` pointer we should return false because this library assumes that you've
            // run dereferencing beforehand.
            return false;
        }
        if (mediaType) {
            if (!(mediaType in requestBody.content)) {
                return false;
            }
            return requestBody.content[mediaType];
        }
        // Since no media type was supplied we need to find either the first JSON-like media type that we've got, or the
        // first available of anything else if no JSON-like media types are present.
        var availableMediaType;
        var mediaTypes = this.getRequestBodyMediaTypes();
        mediaTypes.forEach(function (mt) {
            if (!availableMediaType && matches_mimetype_1["default"].json(mt)) {
                availableMediaType = mt;
            }
        });
        if (!availableMediaType) {
            mediaTypes.forEach(function (mt) {
                if (!availableMediaType) {
                    availableMediaType = mt;
                }
            });
        }
        if (availableMediaType) {
            return [availableMediaType, requestBody.content[availableMediaType]];
        }
        return false;
    };
    /**
     * Retrieve an array of request body examples that this operation has.
     *
     */
    Operation.prototype.getRequestBodyExamples = function () {
        if (this.requestBodyExamples) {
            return this.requestBodyExamples;
        }
        this.requestBodyExamples = (0, get_requestbody_examples_1["default"])(this.schema);
        return this.requestBodyExamples;
    };
    /**
     * Return a specific response out of the operation by a given HTTP status code.
     *
     * @param statusCode
     */
    Operation.prototype.getResponseByStatusCode = function (statusCode) {
        if (!this.schema.responses) {
            return false;
        }
        if (typeof this.schema.responses[statusCode] === 'undefined') {
            return false;
        }
        var response = this.schema.responses[statusCode];
        if (RMOAS.isRef(response)) {
            return false;
        }
        // Remove the reference from the type, because it will already be dereferenced.
        return response;
    };
    /**
     * Retrieve an array of response examples that this operation has.
     *
     */
    Operation.prototype.getResponseExamples = function () {
        if (this.responseExamples) {
            return this.responseExamples;
        }
        // @todo Remove this `as` once we convert getResponseExamples
        this.responseExamples = (0, get_response_examples_1["default"])(this.schema);
        return this.responseExamples;
    };
    /**
     * Determine if the operation has callbacks.
     *
     */
    Operation.prototype.hasCallbacks = function () {
        return !!this.schema.callbacks;
    };
    /**
     * Retrieve a specific callback.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#callbackObject}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#callbackObject}
     * @param identifier Callback identifier to look for.
     * @param expression Callback expression to look for.
     * @param method HTTP Method on the callback to look for.
     */
    Operation.prototype.getCallback = function (identifier, expression, method) {
        if (!this.schema.callbacks)
            return false;
        // The usage of `as` in the below is to remove the possibility of a ref type, since we've dereferenced.
        var callback = this.schema.callbacks[identifier]
            ? this.schema.callbacks[identifier][expression]
            : false;
        if (!callback || !callback[method])
            return false;
        return new Callback(this.api, expression, method, callback[method], identifier, callback);
    };
    /**
     * Retrieve an array of operations created from each callback.
     *
     */
    Operation.prototype.getCallbacks = function () {
        var _this = this;
        var callbackOperations = [];
        if (!this.hasCallbacks())
            return false;
        Object.keys(this.schema.callbacks).forEach(function (callback) {
            Object.keys(_this.schema.callbacks[callback]).forEach(function (expression) {
                var cb = _this.schema.callbacks[callback];
                if (!RMOAS.isRef(cb)) {
                    var exp = cb[expression];
                    if (!RMOAS.isRef(exp)) {
                        Object.keys(exp).forEach(function (method) {
                            if (!utils_1.supportedMethods.has(method))
                                return;
                            callbackOperations.push(_this.getCallback(callback, expression, method));
                        });
                    }
                }
            });
        });
        return callbackOperations;
    };
    /**
     * Retrieve an array of callback examples that this operation has.
     *
     */
    Operation.prototype.getCallbackExamples = function () {
        if (this.callbackExamples) {
            return this.callbackExamples;
        }
        this.callbackExamples = (0, get_callback_examples_1["default"])(this.schema);
        return this.callbackExamples;
    };
    /**
     * Determine if a given a custom specification extension exists within the operation.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specificationExtensions}
     * @param extension Specification extension to lookup.
     */
    Operation.prototype.hasExtension = function (extension) {
        return Boolean(this.schema && extension in this.schema);
    };
    /**
     * Retrieve a custom specification extension off of the operation.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#specificationExtensions}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#specificationExtensions}
     * @param extension Specification extension to lookup.
     */
    Operation.prototype.getExtension = function (extension) {
        var _a;
        return (_a = this.schema) === null || _a === void 0 ? void 0 : _a[extension];
    };
    return Operation;
}());
exports["default"] = Operation;
var Callback = /** @class */ (function (_super) {
    __extends(Callback, _super);
    function Callback(oas, path, method, operation, identifier, parentPathItem) {
        var _this = _super.call(this, oas, path, method, operation) || this;
        _this.identifier = identifier;
        _this.parentSchema = parentPathItem;
        return _this;
    }
    /**
     * Return the primary identifier for this callback.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#callback-object}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#callbackObject}
     */
    Callback.prototype.getIdentifier = function () {
        return this.identifier;
    };
    Callback.prototype.getSummary = function () {
        var _a;
        if (this.parentSchema.summary) {
            return this.parentSchema.summary;
        }
        return ((_a = this.schema) === null || _a === void 0 ? void 0 : _a.summary) ? this.schema.summary.trim() : undefined;
    };
    Callback.prototype.getDescription = function () {
        var _a;
        if (this.parentSchema.description) {
            return this.parentSchema.description;
        }
        return ((_a = this.schema) === null || _a === void 0 ? void 0 : _a.description) ? this.schema.description.trim() : undefined;
    };
    Callback.prototype.getParameters = function () {
        var _a;
        var parameters = (((_a = this.schema) === null || _a === void 0 ? void 0 : _a.parameters) || []);
        var commonParams = (this.parentSchema.parameters || []);
        if (commonParams.length) {
            parameters = parameters.concat((0, dedupe_common_parameters_1["default"])(parameters, commonParams) || []);
        }
        return parameters;
    };
    return Callback;
}(Operation));
exports.Callback = Callback;
var Webhook = /** @class */ (function (_super) {
    __extends(Webhook, _super);
    function Webhook() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Webhook;
}(Operation));
exports.Webhook = Webhook;
